#+TITLE: Readme

A number of tools and functions
to do hierarchical domain decomposition
of hypercubic lattices
and managing the memory layout.

*Nothing clever or revolutionary here*.

* Main Ideas
Hypercubic lattices have
"partitioning" symmetries
that constrain the
most general memory layout that can be sensibly adopted.

By "partitioning symmetry",
I refer to the fact that if we partition
`----------------`
into
`|----|----|----|----|`
each one of the 4 chunk has the same shape.

HPC machines tend to have
a more and more hierarchical
memory structure, for example:
- vector lanes
- core-specific caches
- socket-specific caches
- node ram
- the whole memory used
  by a distributed data structure
  (which is only an abstraction,
  that makes anyway sense)
- whatever else vendors may come up with.

Of course, such memory structure
can break the "partitioning" symmetries of the lattice,
so one might have to adopt memory layouts
that do not respect
such symmetries.
The point is:
how much do we need
to break the symmetry
to have an efficient implementation?
The less we break it,
the easier the code will be
to write
and to understand once it's written.

* Definition of memory layout
A memory layout for a lattice
is a function that takes the coordinates

x_0, ... , x_d

of a point
and returns a natural number:

idx = f ( x_0, ... , x_d )

A hypercubic lattice has also
global dimensions

L_0, ... , L_d

A memory layout function
allows us to completely abstract
the problem of finding lattice sites in memory.
It can either be used on-line,
or the results can be cached,


** Decomposition of dimensions in factors

We can decompose all the dimensions
as a product of factors:

L_0 = F_00 * ... * F_0(n_0-1)
...
L_d = F_d0 * ... * F_d(n_d-1)

For the sake of argument,
and to support following examples,
let's assume:

L_0 = 32 = 2 * 2 * 4 * 2
L_1 = 27 = 3 * 9
L_2 = 35 = 5 * 7


** Express coordinates using the decomposition factors

We can re-express
the individual components of the coordinates
using the decomposition factors
of the relative dimension,
in a way similar to the one used
in positional numeral systems.

For the sake of argument,
using the previous decomposition of L_0,
let's assume:

x_0 = 25 = 1 * 1 +
           0 * 1 * 2 +
           1 * 1 * 2 * 2
           1 * 1 * 2 * 2 * 4

The we can represent x_0 as follows:

x_0 <--> (x_00,x_01,x_02,x_03)
x_0 <--> (1,0,1,1)

using the /strides/

s_00 = 1
s_01 = 1 * 2
s_02 = 1 * 2 * 2
s_03 = 1 * 2 * 2 * 4

Where obviously

s_i0 = 1
s_ij = s_i(j-1) * F_i(j-1)

Let's choose also x_1 and x_2

x_1 = 14 = 2 * 1 +
           4 * 1 * 3

x_2 = 26 = 1 * 1 +
           5 * 1 * 5


We can then express the lattice point

x = ( x_0, x_1, x_2 )

as
x = ((1, 0, 1, 1),
     (2, 4),
     (1, 5))

** Lexicographic memory layout

A possible memory layout is the following:

idx = x_0 * 1 +
      x_1 * 1 * L_0 +
      x_2 * 1 * L_0 * L_1 +
      x_2 * 1 * L_0 * L_1 * L_2

which can be expressed as the list

[L_0,L_1,L_2,L_3]

We can define the memory layout
to be the function f such that

idx = f([L_0,L_1,L_2,L_3],[x_0,x_1,x_2,x_3])

Another completely equivalend memory layout is

idx = x_00*1 +             // From L_0
      x_01*1*2 +           //
      x_02*1*2*2 +         //
      x_03*1*2*2*4 +       //
      //
      x_10*1*2*2*4*2 +     // From L_1
      x_11*1*2*2*4*2*3 +   //
      //
      x_20*1*2*2*4*2*3*9 + // From L_2
      x_21*1*2*2*4*2*3*9*5 //
          \ L0    \L1 \L2 \


Which can be expressed as

idx = f([F_00, F_01, F_02, F_03, F_10, F_11, F_20, F_21],
        [x_00, x_01, x_02, x_03, x_10, x_11, x_20, x_21])

Now, an obvious statement:
/if we apply the same permutation
to the list of Fs
and to the list of xs,
we get a valid memory layout/.

Another statement:
/the memory layout functions
can be made modular./

* Breaking the symmetry
** Halos, Borders, and bulk
Splitting each portion of a lattice
into halos, borders and bulk
obviously requires
a more complex memory layout,
because it breaks the partitioning symmetry.

The situation is:
- For Local data
  Each direction can be split into 3 pieces:
  - Border-,
  - Bulk,
  - Border+
- For Cached Remote data
  - Halo-
  - Halo+
The size of Borders and Halos can be zero.

We can recover the symmetry
at a higher level,
by splitting each 1D portion in 5 pieces.
We have then at least an elegant & simple way
to refer to each portion.
This can be done at each level in the decomposition.

*How this plays with the hierarchical aspect
still requires some investigation/ideas*.

Notice that this requires having up to 5^D portions,
and this might be impractical.

We can, though, allocate only
the ones that we are interested in
by defining them all and then
filtering out the ones we do not want,
according to different requirements:
- having size > 0
- having at least nd_min sides > 1

For each level in the decomposition,
or for each stride,
we have a halo thickness h.

Example:

For L_0 = 2 * 2 * 4 * 2,

We can have

s_00 = 1 , h_00 = 0
s_01 = 2 , h_01 = 0
s_02 = 4 , h_02 = 1
s_03 = 16, h_03 = 1

Notice that if i<j, h_ki <= h_kj.

** EO ordering
Proposed solution:
- requires at least one dimension to be even
  *in the "local" memory layout*
- Increase the dimensionality of the array by 1,
  and another index which will be 0 or 1
- make the chosen even direction half of its original value

** Uneven partitioning

Requiring the dimension of the lattice
to have certain factors can be too restrictive.
In HiRep it is possible to have unequal MPI partitioning,
and it should be possible to replicate this
in a hierarchical way.
